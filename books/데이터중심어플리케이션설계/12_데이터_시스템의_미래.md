# 데이터 시스템의 미래
관심있게 본 것
- “선장의 가장 큰 목적이 배를 보존하는 것이라면 배는 영원히 항구에 머물 것"
- 데이터 통합
    - 여러 소프트웨어를 하나로 묶기
    - 파생 데이터에 특화된 도구의 결합
        - 데이터 통합의 필요성은 나무가 아닌 숲을 보기 위해 줌아웃해서 조직 전체 데이터플로를 고려할 때야 비로소 명확해진다
        - 데이터플로에 대한 추론
            - 입력과 출력을 분명히 할 필요가 있다.
            - 파생 데이터 시스템은 이벤트 로그를 기반으로 갱신하면 결정적이고 등성을 지녀 결함에서 복구하기가 상당히 쉬워진다.
        - 파생 데이터 대 분산 트랜잭션
            - 분산 트랜잭션은 원자적 커밋을 사용해 변경효과가 정확히 한 번 타나도록 보장한다. (선형성)
            - 로그 기반 시스템은 결정적 재시도와 멱등성을 기반으로 한다.
        - 전체 순서화의 제약
            - 이벤트의 순서를 정하는 작업을 여로 노드에서 공유하는 메커니즘은 제공하지 않는다.
            - 단일 노드의 처리량을 넘어서는 규모와 지리적으로 분산된 설정에서 잘 동작하는 합의 알고리즘 설계는 아직 해결되지 않은 연구 과제다.
        - 인과성 획득을 위한 이벤트 순서화
            - 친구 끊기와 메시지 보내기는 순서 의존성이 없지만 친구를 끊고 이전 친구에게 잘못된 알림을 보낼 수 있다.
    - 일괄 처리와 스트림 처리
        - 데이터 통합의 목표는 데이터를 올바른 장소에 올바른 형태로 두는 것
        - 파생 상태 유지
            - 색인을 비동기 방식으로 유지한다면 이런 파티션 간 통신에서 더욱 신뢰성 있고 확장성이 좋아진다
        - 애플리케이션 발전을 위한 데이터 재처리
            - 철도 스키마 이전
                - 폭이 다른 열차 일괄 맞추기
                - 모두 달릴 수 있는 세번째 레일을 만듬
        - 람다 아키텍처
            - 입력 데이터를 불변 이벤트로서 증가하기만 하는 데이터셋에 추가하는 방식으로 기록
        - 일괄 처리와 스트림 처리의 통합
- 데이터베이스 언번들링
    - 유닉스와 데이터베이스 비교
    - 나는 이번 절에서 양쪽 세계의 장점을 결합하기를 바라는 마음으로 두 철학을 화해시키려 한다.
    - 데이터 저장소 기술 구성하기
        - 데이터베이스에 내장된 기능과 일괄 처리와 스트림 처리로 구축하는 파생 데이터 시스템 사이에는 유사성이 있다.
        - 모든 것의 메타데이터베이스
            - 일괄처리와 스트림 처리로 유지하는 파생 데이터 시스템은 마치 다양한 색인 유형과 비슷하다
            - 연합 데이터베이스(읽기 통합), 언번들링 데이터베이스(쓰기 통합)
        - 언번들링이 동작하게 만들기
            - 로그 기반 통합의 큰 장점은 느슨한 결합이다
        - 언번들링 대 통합 시스템
            - 언번들링의 목표는 몇 개의 다른 데이터베이스를 결합해 단일 소프트웨어로 가능한 것보다 더 넓은 범위의 작업 부하에 대해 좋은 성능을 달성하기 위함
        - 뭐가 빠졌지?
            - 유닉스 쉘과 동일한 언번들링된 데이터베이스가 존재하지 않는다.
            - 캐시 사전 계산
            - 미분 데이터플로우 
    - 데이터플로 주변 애플리케이션 설계
        - 데이터베이스 인사이드 아웃
        - 모든 소프트웨어가 특정 언어와 프레임워크 또는 도구만을 사용해 개발될 것으로 기대하는 것은 비현실적이다.
        - 애플리케이션 코드와 상태의 분리
            - 나는 시스템의 일부는 지속성 있는 데이터 저장을 전문으로 하고 다른 일부는 애플리케이션 코드 실행을 전문으로 하는게 합리적이라 생각한다.
            - 변경 데이터 구독은 이제 막 등장하기 시작한 기능이다.
        - 데이터플로: 상태 변경과 애플리케이션 코드 간 상호작용
            - 가장 명심해야 할 점은 파생 데이터를 유지하는 것이 전통적인 메시징 시스템의 설계 목적인 비동기 작업 실행과는 같지 않다는 것이다.
        - 스트림 처리자와 서비스
            - 가장 빠르고 가장 신뢰성 있는 네트워크 요청은 네트워크 요청을 전혀 하지 않는것이다.
    - 파생 상태 관찰하기
        - 파생 데이터셋은 쓰기 시간에 필요한 작업의 양과 읽기 시간에 필요한 작업의 양 간에 트레이드오프를 나타낸다.
        - 구체화 뷰와 캐싱
            - 색인이 없으면 쓰기 경로의 작업량은 줄지만 읽기 경로의 작업이 상당히 늘어난다.
        - 오프라인 대응 가능한 상태 저장 클라이언트
            - 오프라인 우선 애플리케이션은 인터넷 연결 요구 없이 같은 장치의 로컬 데이터베이스를 이용해 가능한 많은 일을 하고 네트워크 연결이 가능할 때 백그라운드에서 원격 서버와 동기화 한다.
        - 상태 변경을 클라이언트에게 푸시하기
            - 서버전송 이벤트 소스, 웹소켓은 서버가 주도적으로 브라우저에 보내는 방식의 통신 채널을 제공한다.
            - 각 장치는 작은 이벤트 스트림을 구독하는 작은 구독자다.
        - 종단 간 이벤트 스트림
            - 문제는 상태 비저장 클라이언트와 요청/응답 방식의 상호작용이 데이터베이스, 라이브러리, 프레임워크, 프로토콜에 뿌리깊게 배어있기 때문이다.
        - 읽기도 이벤트다.
- 정확성을 목표로
    - 전통적인 트랜잭션 접근법이 사라지고 있지는 않지만 나는 이것이 애플리케이션을 정확하게 만들고 결함에 견딜 수 있는 최후의 방법이라고 믿지는 않는다.
    - 데이터베이스에 관한 종단 간 논증
        - 불변성이 유용하긴 해도 그 자체가 만능은 아니다.
        - 연산자의 정확히 한번 실행
            - 가장 효과적인 접근법 중 하나는 연산을 멱등으로 만드는 것이다.
        - 중복 억제
        - 연산 식별자
            - 연산 ID를 만들어서 중복을 제거할 수 있다
        - 종단 간 논증
            - 트랜잭션 식별자를 포함
    - 제약 조건 강제하기
        - 유일성 제약조건은 합의가 필요하다
    - 적시성과 무결성
        - 적시성은 사용자가 시스템을 항산 최신 상태로 관측 가능하다는 의미
        - 무결성은 손상이 없다는 의미
        - 느슨하게 해석되는 제약조건
            - 비행기 오버부킹, 사과
        - 코디네이션 회피 데이터 시스템
            - 더 성능이 좋고 더 나은 내결합성을 가짐
            - 사과의 수를 0으로 줄일 수 없지만 요구사항에 따라 최상의 트레이드오프를 찾는 것을 목표로 해야한다.
    - 믿어라. 하지만 확인하라
        - 컴퓨터가 하는 실수를 계속 걱정해야 한다면 아무것도 하기 어려울 것이다.
        - 자세히 들여다보면 하드웨어는 보기보다 추상화를 완벽하게 제공하지 않는다.
        - 소프트웨어 버그가 발생해도 무결성 유지하기
            - 데이터베이스는 항상 일관성 있는 상태에 있으리라고 기대하지만 이 생각은 트랜잭션에 버그가 없을때만 통한다
        - 약속을 맹목적으로 믿지 마라
            - 데이터 무결성을 체크하는 작업을 감사라고 한다.
        - 검증하는 문화
            - 미래에는 무결성 확인을 백지 위임하기 보다는 스스로 무결성 확인을 지속적으로 수행하는 자가 검증이나 자가 감사 시스템을 더 많이 볼 수 있길 바란다.
        - 감사 기능 설계
            - 이벤트 기반 시스템은 더 나은 감사 기능을 제공한다
            - 결정적이고 잘 정의한 데이터플로를 사용하면 디버깅과 시스템에서 왜 그렇게 행동했는지 판별하기 위한 추적이 쉬워진다.
        - 다시 종간 논증
            - 무결성 확인이 가능한 시스템이 많을수록 처리 과정의 어떤 단계에서 손상이 발견되지 않을 가능성이 낮아진다.
        - 감사 데이터 시스템용 도구
            - 암호화 도구를 사용해 시스템의 무결정을 증명하려는 시도는 흥미롭다 (코인 채굴 등)
            - 나는 비잔틴 내결함성 측면에서 이 기술에 대해 다소 회의적이다.
            - 작업 증명 기술이 엄청나게 소모적이라고 생각한다.
            - 머클트리
- 옳은 일 하기
    - 사용자도 인간이다. 인간의 존엄성은 그 무엇보다 중요하다.
    - 소프트웨어 엔지니어도 윤리적 책임을 져야한다.
    - 예측 분석
        - 알고리즘 감옥
        - 편견과 차별
            - 알고리즘에 투입된 입력에 편견이 있다면 그 편견을 증폭해서 출력을 내보낼 가능성이 높다.
            - 데이터와 모델은 도구여야지 주인이 되어서는 안된다.
        - 책임과 의무
            - 신용 등급 기관 이야기
            - 의사결정에 데이터를 최우선으로 하는 맹목적 믿음은 망상일 뿐 아니라 절대적으로 위험하다. 데이터 주도 의사결정이 보편화될수록 알고리즘을 설명 가능하고 투명하게 만드는 방법을 찾아야 한다.
        - 피드백 루프
            - 에코 체임버
            - 최선의 의도였더라도 의도하지 않은 결과를 반드시 주의해야 한다.
    - 사생활과 추적
        - 사용자 추적은 주로 개인을 위한 것이 아니라 서비스에 돈을 대는 광고주의 필요로 제공한다.
        - 감시
            - 데이터란 단어를 감시로 바꾸고 여전히 좋은 문구로 들리는지 사고 실험을 해보자
        - 동의와 선택의 자유
            - 서비스가 네트워크 효과를 가지면 해당 서비스를 사용하지 않기를 선택하는 사람들이 지불해야 할 사회적 비용이 존재한다.
        - 사생활과 데이터 사용
            - 사생활 보호가 모든것을 비밀로 한다는 뜻은 아니다.
            - 시스템 엔지니어는 겸손해야 하고 이런 결함을 수용하고 대비해야 한다.
        - 산업혁명이 가진 어두운 면을 관리할 필요가 있는 것처럼 정보화 시대로 이전할 때 직면하는 주요한 문제들을 풀어야 한다.
    - 법률과 자기 규제
        - 개인 데이터 기술 산업에 문화 전환이 필요하다.
        - 기업과 소프트웨어 개발자는 사용자 데이터가 어떻게 사용하는지 감추지 않고 최종 사용자에게 교육할 책임이 있다.

소감
- 교수님.. 마지막 수업은 원래 단축 수업입니다만..
- 전체적으로 줄 그어가면서 읽었는데 결국 머리속에는 윤리만 남네요 ㅎㅎ;;
- 이전 회사에서 마이데이터 사업을 했었는데 데이터 주권이라는 표현을 사용하더라구요. 데이터의 주인이 기업에서 개인으로 옮겨가는..
- 다만 교수님도 적으셨듯이 데이터를 가져와 활용하고 싶어하는 기업은 많은데 이것을 사람들에게 알리고 지식을 전파하는 기업이 있는지는 사실 의문입니다. 직전 회사도 그렇고 최근 퇴직금 통장 해지를 위해 은행을 방문했었는데 그때도 가입하면 기프티콘을 준다는 말과 함께 마이데이터 서비스 가입을 유도하더라구요. (뭐하는건지 잘 알지도 못한 채 그냥 가입 하는 사람들이 많았습니다 ㅠ)
- 이런걸 보면서 교수님이 왜 마지막에 소프트웨어 엔지니어들의 윤리의 중요성을 말씀하셨는지 알거 같았습니다. 최근 기술발전이 너무 빨라지면서 법과 현실의 괴리감이 점점 커지고 있는데 개인의 최소한의 윤리라도 없다면 정말 큰일이 날거 같아요.
